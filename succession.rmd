---
title: "Sucesión ecológica con R"
author:
date:
output: github_document
editor_options: 
  chunk_output_type: console
---
![](succession_files/figure-markdown_github/sucesion_stand_dev0_100.png)

### Un modelo analítico de sucesión
Estos modelos son simplificaciones de los procesos reales, pero permiten fijarse en los aspectos básicos de la dinámica de sustitución de especies, y compararla entre distintas comunidades, o vías de sucesión. 

Planteamos un modelo matricial análogo al usado para modelar (ctrl. click) [dinámica de poblaciones estructuradas](https://github.com/quevedomario/eco3r/blob/master/stages.md) en clases de edad o estadios.
Ese modelo plantea en este caso de qué manera las comunidades cambian de estado a lo largo del tiempo. Esos estados los asumimos o construimos discretos, sin solapamiento.

El ejercicio requiere escasa preparación previa. Usamos las librerías **popbio** para procesar las probabilidades de sustitución, **pander** para mejorar la presentación de resultados, y **diagram** para dibujar ciclos. No son imprescindibles, todo se podría hacer con R básico.
```{r message=FALSE, warning=FALSE}
library(popbio)
library(pander)
library(diagram)
```

Vamos a usar como ejemplo el cambio temporal en un ecosistema cuyos estadios reconocibles a lo largo de una sucesión ecológica son *espacio abierto*, *pradera*, *matorral*, y *bosque*^1^. Esencialmente un esquema de sucesión común a los ecosistemas forestales.

Necesitamos saber donde empieza la sucesión, y las *probabilidades de transición* de un estado de la comunidad al siguiente^2^. En este ejemplo partiremos de un paisaje - la foto fija de un ecosistema - en el que tenemos 500 parches de hábitat, todos en el estado inicial de la sucesión, *espacio abierto*. Con esa información construiremos  más adelante el **vector de estado inicial**, **N~0~**.

#### Matriz de transición
Un modelo como este en el que reconocemos 4 estados (*fases*, *estadios*, da igual) requiere una matriz cuadrada con cuatro filas y cuatro columnas, que contienen las probabilidades de transición del estado actual (columnas) al siguiente (filas).

Para introducir los datos y construir la matriz definimos primero las etiquetas de los **estados**, almacenándolos en un vector de texto con `c()`. 
```{r}
estados <- c("espacio abierto","pradera","matorral","bosque") 
```

A continuación almacenamos las **probabilidades** de transición en otro vector, numérico en este caso (i.e. valores sin comillas). 
```{r}
probabilidades <- c(
  0.65, 0.23,	0.25,	0.40,
  0.15,	0.70,	0.25,	0.10,
  0.00,	0.07,	0.25,	0.15,
  0.20,	0.00,	0.25,	0.35
  )
```

Por último, combinamos estados y probabilidades en la **matriz** de proyección con la función `matrix2()`. Los paréntesis rodeando a esta le piden a R que nos la enseñe directamente:  
```{r}
(matriz <- matrix2(probabilidades, estados))
```

La matriz muestra probabilidades de sustitución del tiempo *t* al tiempo *t+1*. Así, la probabilidad de que un parche de *espacio abierto* pase a *pradera* es 0.15, mientras que la probabilidad de que un parche de *bosque* pase a *pradera* es 0.10. La diagonal de la matriz indica la probabilidad de que un parche permanezca en el mismo estado entre *t* y *t+1*. Los valores de cada columna deben sumar 1.0, ya que recojen el estado de los parches en el tiempo *t*.

#### Diagrama de sucesión
Podemos representar gráficamente las transiciones de la matriz con la intimidante pero útil función `plotmat()`, vista en ejercicios anteriores. 
`?plotmat` devuelve la explicación del significado de cada argumento de la función.
```{r, fig.align="center", fig.asp=0.8}
plotmat(matriz, relsize =0.70, self.cex = 0.5, self.shifty=0.10, self.shiftx = c(0.07,0.16,-0.23,0),
        box.prop = c(0.4,0.3,0.3,0.3), box.type = "round", box.size = 0.14, lwd = 1.2, 
        arr.col = "green", arr.lcol = "black", arr.type = "triangle", txt.col = "blue",
        main = "Sucesión en ecosistema forestal")
```

#### Proyecciones
Para almacenar los resultados de cada intervalo de sustitución construimos una matriz con tantas filas como intervalos de tiempo pretendidos, y 4 columnas para los 4 estados. La primera línea del código a continuación deja definida esa matriz **proyecciones** para 6 intervalos, y vacía.

La segunda define la variable de intervalos de tiempo, hasta 20.

A continuación usamos los nombres de los estados y 6 intervalos de tiempo para etiquetar las columnas `colnames()` y las filas `rownames()` en **proyecciones**. 

Después definimos el estado inicial de la comunidad *N~0~*; en este caso los 500 parches de hábitat están en fase *espacio abierto*:
```{r}
proyecciones <- matrix(nrow = 6, ncol = 4)

tiempo <- seq(from=0, to=20, by=1)

colnames(proyecciones) <- estados
rownames(proyecciones) <- (tiempo[2:7])
proyecciones

n0 <- c(500,0,0,0)
```

Las proyecciones de estos modelos de sustitución son multiplicaciones sucesivas de la matriz de probabilidades por el vector de abundancias en el tiempo *t*, o *vector de estado*. Para automatizar las proyecciones durante *i* intervalos de sustitución podemos usar un bucle. Una de las formas de prepararlos en **R** es la función `for()`: 

```{r}
for (i in 1:6) {
  n0 <- matriz %*% n0
  proyecciones[i,] <- n0
  pander(proyecciones[i,])
  Sys.sleep(0.5)
  }
```

El bucle `for` se lee "*para cada intervalo de tiempo de 1 a 6, almacena como n0 el resultado de multiplicar la matriz por el N~0~ previo, guarda el resultado en la fila i de proyecciones, y muestra esa última fila o vector de estado*"^3^.   
En la consola **R** aparecerán sucesivamente los vectores de estado *N~1~* a *N~6~*.

```{r}
pander(proyecciones)
```

Para pintar los resultados nos interesa tener en el mismo conjunto de datos el estado inicial de la sucesión, aquel *N~0~* con 500 parches de *espacio abierto*. El código a continuación crea el vector *inicial*, lo combina en **todo** con los resultados de las **proyecciones**, y elimina los nombres de las filas (para pintarlo más fácil):

```{r}
inicial <- c(500,0,0,0)
todo <- rbind(inicial, proyecciones)
rownames(todo) <- NULL
pander(todo)
```

A continuación pintamos el cambio de los parches entre los intervalos t=0 y t=6. En negro *espacio abierto*, en azul *pradera*, en rojo *matorral*, y en verde *bosque*:
```{r}
plot(tiempo[1:7], todo[,1], type="l", xlab="intervalos", ylab = "parches", ylim = c(0,500),
     main="Proyección de N0 durante 6 intervalos de sustitución")
lines(tiempo[1:7], todo[,2], col="blue")
lines(tiempo[1:7], todo[,3], col="red")
lines(tiempo[1:7], todo[,4], col="green")
```

La proyección de cada tipo de parche está almacenada en cada una de las columnas de **todo**. `plot()` pinta la primera curva, la de *espacio abierto*, y a continuación añadimos el resto de curvas al gráfico existente con `lines()`^4^.

El gráfico ilustra una propiedad de estos modelos analíticos: al multiplicar sucesivamente los vectores de estado por la misma matriz de transición, se alcanza una estructura estable. Es decir, el vector de estado deja de cambiar por mucho que proyectemos la dinámica. Y esa estructura se alcanza independientemente de cual sea el estado inicial. En nuestro ejemplo empieza a ser aparente a partir de *N~4~*.

Adaptando el código anterior es fácil incluir cambios en las probabilidades de sustitución. Estas podrían derivarse por ejemplo de una menor frecuencia de perturbaciones, que reduciría la probabilidad de regresión a estados previos de la sucesión (i.e. todas aquellas por encima de la diagonal en la matriz de transición).

#### Referencias y notas
1. Ejemplo adaptado de Gotelli NJ. 2008. A primer of ecology (AD Sinauer, Ed). Sunderland: Sinauer.  
2. Los cambios regresivos son *tarea* de las perturbaciones, y dependen de la intensidad, frecuencia y escala espacial de estas.  
3. En cada repetición **n0** es sustituido por el resultado de multiplicar el anterior por la matriz, si bien el contenido queda guardado en **proyecciones**. Los bucles `for(){}` son útiles para repetir cálculos y almacenar los resultados sucesivos. Entre paréntesis llevan siempre la variable que identifica la secuencia de repeticiones; entre corchetes, el conjunto de operaciones en orden de ejecución. En el ejemplo, `Sys.sleep()` introduce un retraso de medio segundo para ver los resultados sucesivos en la consola. Para acelerar el código podemos prescindir de la visualización de resultados intermedios, y del retraso.  
4. `tiempo[1:7]` hace referencia a las posiciones primera a septima en el vector tiempo, que corresponden a los intervalos *t~0~* a *t~6~*.